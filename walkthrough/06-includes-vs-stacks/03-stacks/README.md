# 03 - Stacks

A third approach that has experimental support today is the `terragrunt.stack.hcl` file. This is a way to define configurations for a generated stack using a special file that doesn't rely on includes for the same kind of DRYness achieved with the `_envcommon` pattern.

## File Structure

```bash
$ eza -T -I 'src|dist|modules|README.md' --group-directories-last
.
├── root.hcl
├── live
│   └── terragrunt.stack.hcl
├── stacks
│   └── environment
│       └── terragrunt.stack.hcl
└── units
    ├── api
    │   ├── package.sh
    │   └── terragrunt.hcl
    └── db
        └── terragrunt.hcl
```

Unlike both of the previous patterns, the Stack pattern doesn't require comitting a `terragrunt.hcl` file to the repository for each piece of state that has to be managed. Instead, each file either defines the infrastructure patterns that are going to be used (in the `modules`, `units` and `stacks` directories), or the configuration for the live infrastructure that's going to be provisioned (in the `live` directory). Files don't have to be committed to the repository for each piece of infrastructure that's going to be managed, which can make the repository easier to manage, especially at larger scale.

```hcl
# units/api/terragrunt.hcl
include "root" {
	path   = find_in_parent_folders("root.hcl")
	expose = true
}

locals {
	project_name = include.root.locals.project_name

	parent_dir   = get_parent_terragrunt_dir("root")

	dist_dir       = "./dist"
	source_dir     = "./src"

	package_script = "./package.sh"

	cur_dir_name = basename(get_terragrunt_dir())
}

terraform {
	source = "${local.parent_dir}/modules/api"

	before_hook "package" {
		commands = ["plan", "apply"]
		execute  = [local.package_script, local.source_dir, local.dist_dir]
	}
}

dependency "db" {
	config_path = "../db"

	# Mock outputs allow us to continue to plan on the apply of the api module
	# even though the db module has not yet been applied.
	mock_outputs_allowed_terraform_commands = ["plan", "destroy"]
	mock_outputs = {
		name = "mock-table"
		arn  = "arn:aws:dynamodb:us-west-2:123456789012:table/mock-table"
	}
}

inputs = {
	name = "${local.project_name}-${local.cur_dir_name}-${values.environment}"

	filename = "${local.dist_dir}/package.zip"

	dynamodb_table = dependency.db.outputs.name
	dynamodb_arn   = dependency.db.outputs.arn
}
```

```hcl
# stacks/environment/terragrunt.stack.hcl
unit "api" {
	source = "${dirname(find_in_parent_folders("root.hcl"))}/units/api"
	path   = "api"

	values = {
		environment = values.environment
	}
}

unit "db" {
	source = "${dirname(find_in_parent_folders("root.hcl"))}/units/db"
	path   = "db"

	values = {
		environment = values.environment
	}
}
```

```hcl
# live/terragrunt.stack.hcl
stack "dev" {
  source = "${dirname(find_in_parent_folders("root.hcl"))}/stacks/environment"
  path   = "dev"

  values = {
    environment = "dev"
  }
}

stack "prod" {
  source = "${dirname(find_in_parent_folders("root.hcl"))}/stacks/environment"
  path   = "prod"

  values = {
    environment = "prod"
  }
}
```

You might notice that the `units/api/terragrunt.hcl` actually looks a lot more similar to the `live/dev/api/terragrunt.hcl` file in the ["Not DRY"](../01-not-dry) pattern than the `_envcommon/api.hcl` file in the ["_envcommon"](../02-envcommon) pattern. This is because the units generated by `terragrunt.stack.hcl` files are actually used as units in-place in the generated stack. Users don't have to reason about a merge of different configurations to determine what the final configuration will look like - all the configuration relevant to the unit _can_ be defined in the unit's `terragrunt.hcl` file. The main exceptions to this are things like remote state configuration and provider configurations from the `root.hcl` file. These are configurations that are almost always boilerplate configurations that don't meaningfully change between units, so users will still typically end up with a `root.hcl` file that's used to define these configurations in this pattern.

Configuration files for units like `package.sh`, which are not exactly unit configurations, but are also tightly coupled to them can also be managed in the same directory as the unit configuration. This can make it easier to reason about the configuration of a unit, as all the files that are relevant to the unit are in the same directory. Unit configurations can also be fetched from remote sources, like a Git repository, which can make it easier to decouple the configuration of a unit from the configuration of the stack. Users can make an atomic version bump of the source for a unit in a `terragrunt.stack.hcl` file pointed to a remote source in a particular environment, and only have those changes applied to that environment. The addition of `values` and the `terragrunt.values.hcl` files they generate also makes it so that it's easier to define environment-specific configurations, like the `environment` value in the `live/terragrunt.stack.hcl` file. Users don't have to use complicated ternary logic that's required in `_envcommon` configurations to get granular control over the configuration of a unit in a particular environment.

## Conclusion

In general, the "Stacks" pattern is the best way for most teams to manage their Terragrunt configurations. It's a more scalable and flexible way to manage configurations at scale, and it's a good fit for what the majority of teams are trying to achieve with Terragrunt. It provides tooling for code reuse, while also providing a way to manage stack-specific configurations for different environments in a way that's easy to reason about. The fact that it _also_ provides a way to stop using the `include` blocks in the "_envcommon" pattern is a nice bonus. Includes are powerful, but the "_envcommon" pattern has been a source of confusion and pain when teams are scaling up their infrastructure estates. Moving away from the "_envcommon" pattern makes it so that includes are only used when they're actually needed, and not as a default way to manage large scale code reuse.

As stated in the other patterns, this is not necessarily a _better_ pattern for all teams. Terragrunt maintainers are introducing this as a new pattern because we think it'll be a better fit for the vast majority of teams, and it scales really well, but it's not a one-size-fits-all solution. Teams that have already invested heavily in the `_envcommon` pattern might not see a lot of value in switching to the `terragrunt.stack.hcl` pattern immediately. Teams that are just starting out with Terragrunt might find the "Not DRY" pattern easier to reason about, and easier to get started with while their team learns how to read Terragrunt configurations. Teams that are struggling with scaling using the `_envcommon` pattern might find the "Stacks" pattern to be a more flexible way to achieve the same goals, without the tight coupling that the `include` blocks in the `_envcommon` pattern introduce.

In-fact, most teams will need to combine elements of these different patterns to achieve their goals with Terragrunt. The `terragrunt.stack.hcl` file is meant to be one more tool in the toolbelt of platform engineers, and while it makes it less necessary to use the `_envcommon` pattern, there are aspects of the pattern that a lot of teams will still end up using. Next, let's explore [combining patterns](../04-combining-patterns) to see how using different parts of these patterns can create a different approach to managing infrastructure with Terragrunt.
